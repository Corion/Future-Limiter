# NAME

Future::Limiter - impose rate and resource limits

# SYNOPSIS

      my $l = Future::Limiter->from_yaml(<<'YAML');
          request:
              # Make no more than 1 request per second
              # have no more than 4 requests in flight at a time
              # If there is a backlog, process them as quickly as possible
              - burst : 3
              rate : 60/60
              - maximum: 4
          namelookup:
              - burst : 3
              rate : 60/60
      YAML

      ...

    my ($host_token, $rate_token);
    $limiter->limit( 'request', $hostname, $url )->then(sub {
        my ($host_token, $url ) = @_;
        request_url( $url )->on_ready( undef $host_token );
    })->then(sub {
        ...
        undef $host_token;
        undef $rate_token;
    });

This module provides an API to handle rate limits and resource limits in a
unified API.

## Usage with Future::AsyncAwait

The usage with [Future::AsyncAwait](https://metacpan.org/pod/Future::AsyncAwait) is much more elegant, as you only need
to keep the token around and other parameters live implicitly in your scope:

    my( $host_token ) = await $concurrency->limit( $hostname );
    my( $rate_token ) = await $rate->limit( $hostname );
    request_url( $url )
    ...

# METHODS

## `$limiter->limit( $eventname, $eventkey, @args )`

    my ($token,@args) = await $limiter->limit('fetch',$url->hostname);
    ... do work
    undef $token; # release token

    $limiter->limit('fetch',$url->hostname,$url)->then(sub( $token, $url) {
        return http_request($url)->on_ready(sub { undef $token });
    };

The method to rate-limit an event from occurring, by key. The key can be
`undef` to mean a global limit on the event.

The method returns a future that will return a token to release the current
limit and the arguments passed in.

# TODO

Persistence of the rate limiter, or periodical writeback of the current limits
to a shared file / scoreboard to allow for cross-process limiting
